* Generalno uopste nije lose, mislio sam da ce biti dosta vise da se komentarise :) cak mi je sistem gde je SVE decentralizovano fascinantno, gde nema nikakvog centralnog GameManager ili slicno, ne znam da li je dobro ali nisam vidjao do sada da radi ok
* Takodje strava ti je organizacija foldera sa skriptama, strava ti je koriscenje delegata za komunikaciju izmedju klasa, i ponajvise je strava sto ti je 80% toga private ukljucujuci sva serijalizovana polja, i APIji klasa su dosta cisti i jasni, takodje naming je dosta dobar
* Taman si sve dekomponovao - mislim i na prefabe i na klase (GridSystem, GridSystemVisual i GridSystemVisualSingle su mi neki od omiljenih), takodje sav k么d na male metode vrh
* Git istorija je grozna xD trudi se cak i kad dzemujes da imas sto vise sitnih komitova, na duze staze ce ti biti bolje cak i sa jednokratnim projektima
* U gitu kad mergujes (gledam merge Dev u main) koristi onaj "fast-forward" koji je ukljucen po difoltu - takodje cisti za sobom tako sto brises merged grane koje se vise ne koriste npr ovu "Dev"
* Struktura foldera sa 0_Scripts 1_Prefabs itd je kul, kontam je, ali mozda ti dugorocno cini neuslugu - odnosno tera te da se oslanjas na redosled, a trebalo bi vise da se oslanjas na search po projektu (koji je dosta dojaja i u unityu i u rideru)
* Dekomponovanje skripti na vise atomicnih (npr Unit, UnitAnimator, UnitRagdollSpawner) je kul i funkcionise, ali se generalno ispostavi da se ne isplati sem ako hoces neke od tih komada cesto da koristis BEZ drugih - a ako se uvek koriste zajedno onda dobijes bolju situaciju kad ih spojis u jedan MonoBehaviour - a kad taj jedan MonoBehaviour previse naraste najbolje je izvlaciti te pod-ponasanja na obicne C# klase
* Scena bi bila organizovanija da razdvojis GUI, i sve sto cini "svet" igre, od infrastrukture - GUI ti je vec odvojen u ono sto ti se zove "Canvas" (bolje da se zove GUI ili UI) - a Ground i Units i Enemies bi bilo dobro da spakujes u neki "World" game object - onda i GUI i World mozes da spakujes u prefabe ako ti ikad deluje korisno
* "Folder" na sceni je u sustini los koncept, samo si strpao sve sisteme u to - zapravo deluje da bi bolje bilo imati samo jedan MonoBehaviour - npr GameManager koji bi mogao da stavis na World game objekat - a onda sve sisteme instancirati u GameManager-u kao obicne C# klase umesto kao MonoBehaviours (generalno zelis sto vise obicnih klasa a sto manje MonoBehaviours, kad to ima smisla)
* BaseAction i generalno akcije takodje nisu neki koncept koji treba da bude MonoBehaviours, to su obicne C# klase k'o vrata - koji se instanciraju na pocetku u svakom Unit-u
* IsometricCameraController nekako bleji diskonektovan od svega - trebalo bi da je skripta vezana za kameru zar ne? ili mozda dete kamere nzm
* Dosta imas "magic numbers" i "magic words" po kodu - generalno sve vrednosti brojeva i stringova sem difoltnih treba biti definisane ili kao konstante ili kao serijalizovane vrednosti, a ne direktno u metodi - savet je da sve cisto tehnicke vrednosti drzis u konstantama a sve sto je deo game dizajna bude po serijalizovanim - takodje ako ti treba centralizovano mesto za neke game dizajn vrednosti (npr statovi za tip jedinice) za to koristi scriptable object ili slican konfig fajl
* Zelis da koristis sto vise immutable state i sto manje object initializers - npr u EnemyAiAction sva polja treba da su readonly i da se setuju samo kroz konstruktor - ovako olaksavas state management i smanjujes kompleksnost projekta
* Getter koji ne prima nikakav parametar i ne menja nista obicno treba da je Property - npr TurnSystem.GetTurnNumber() je prirodniji kao property TurnSystem.TurnNumber - takodje ako to uradis ne treba ti vise ni polje, samo mrdzuj sve u property sa privatnim setterom - public int TurnNumber { get; private set; } - i ista prica za TurnSystem.IsPlayerTurn, i na mnoooogo mesta u projektu mozes da skratis nepotreban k么d sa ovakvim auto-properties
* Jedan tip koji sam naucio radeci na Heroicu vezan za RPGs - umesto da cuvas health i maxHealth, cuvaj maxHealth i healthPercentage, a health racunaj kao maxHealth*healthPercentage - tako ces dobiti da se sve normalno ponasa i kad dobijes neke buffove i bonuse itd
* HealthSystem.GetHealthNormalized() je takodje nesto sto bi bilo prirodno kao getter property
* Izbegavaj GetComponent<> i sve slicne varijante, nego kad god je moguce uvezi skripte kroz serijalizovana polja - konkretno gledam Unit.Awake() i UnitAnimator.Awake()
* Implementirao si Singleton pattern gomilu puta i zbog toga imas nepotrebno dupliran k么d - umesto toga implementiraj jedan genericki MonoSingleton<T> i koristi ga gdegod ti treba - ima jedan trik, evo ti hint: "public class TurnSystem : MonoSingleton<TurnSystem>"
* Jos jedan tip iz Heroica - kad god implementiras neko trajanje/cekanje/stagod, implementiraj ga kao normalizovani progres - npr umesto "timer -= Time.deltaTime;" radi "progress += totalTime / Time.deltaTime;" - tako se obezbedjujes da sve bude ok i ako se usred toga ubrza/uspori vreme i takodje je k么d uniformno razumljiv i prostiji
* GridPosition - nisam siguran ali prilicno deluje da je ista klasa kao Vector2Int, tako da samo iskoristi Vector2Int i mozes ovu da obrises verovatno - rekoh mozda si dodao da bi imao (x, z) umesto (x, y), ali za tu razliku ne vredi napraviti celu novu klasu koja radi sve isto
* Gledam GridSystem.CreateDebugObjects - ne koristi Instantiate+GetComponent, nego koristi Instantiate za tip komponente koja ti treba, tj "debugPrefab" nemoj da serijalizujes i prosledis kao Transform, nego kao GridDebugObject, i onda ti GetComponent ne treba - generalno serijalizuj prefabe kao tip komponente koja ti iz njega primarno treba
* Ne koristi eksplicitne deklaracije tipa za lokalne promenljive, koristi "var" gde god je moguce, lakse se cita i lakse refaktorise a nista ne oduzima